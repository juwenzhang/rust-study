# Rust 数据序列

## 数组 `array`
### 数组的定义
* 数组是相同类型的元素的集合
* 数组的每个元素都有一个唯一的索引，用于访问该元素
* 数组的索引从 0 开始
* 数组的长度是固定的，一旦定义了数组的长度，就不能再改变
* 数组的内存地址是连续的呐

```rust
// 定义一个数组
let arr = [1, 2, 3, 4, 5];

// 访问数组的元素
let first = arr[0];
let second = arr[1];

// 数组的长度
let len = arr.len();

// 数组的遍历
for i in 0..len {
    println!(arr[i]);
}

// 数组的遍历
for i in arr {
    println!(i);
}
```
> 注意，通过 let 定义的数组是不可变的，如果你想要定义一个可变的数组的话，你可以使用 `mut` 关键字来进行定义

### 可变数组
* 可变数组的定义： 可变数组的定义和不可变数组的定义类似，只是在定义时需要使用 `mut` 关键字来进行定义
```rust
let mut arr = [1, 2, 3, 4, 5];

// 访问可变数组的元素
let first = arr[0];
let second = arr[1];

// 可变数组的遍历
for i in 0..len {
    println!(arr[i]);
}

// 可变数组的遍历
for i in arr {
    println!(i);
}

// 可变数组的修改
arr[0] = 100;
```

### 指定大小数组
* 基本格式 `[数据; 大小]`
```rust
let mut arr = [4; 5000]; // 定义了一个长度为 5000 的数组，数组的每个元素都是 4

// 进行元素的变化
for i in 0..1000 {
    arr[i] = i;
}

print!("{:?}", arr);
```
```rust
// 实现一个斐波拉切数组
let mut fib = [1; 100];
for i in 2..fib.len() {
    fib[i] = fib[i - 1] + fib[i - 2];
}
for i in 0..fib.len() {
    println!(fib[i]);
}
```

### 多维数组
* 多维数组的定义： 多维数组的定义和一维数组的定义类似，只是在定义时需要使用 `mut` 关键字来进行定义
```rust
let mut arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
```
```rust 
let mut arr = [[4; 3]; 2; 3];  // 此时就定义了一个多维度数组了，很简洁
```

## 向量 `vec`

### 基础概念
* vec 和 数组是十分类似的，但是整体在开发中使用得比较多的还是 vec 向量
    * 数组是一个固定大小的序列，而 vec 是一个动态大小的序列
    * 数组的大小是在定义时就确定了的，而 vec 的大小是可以动态变化的
    * 数组的元素类型必须是相同的，而 vec 的元素类型可以是不同的
> 和其他语言迁移对比：array 就是数组，但是在平时的开发中用得比较多的还是List vec，因为 vec 是动态大小的序列，而 array 是固定大小的序列

### 定义形式
* vec 的定义形式： `let mut vec = vec![1, 2, 3, 4, 5];`
* vec 的定义形式： `let mut vec = Vec::new();`
* vec 的定义形式： `let mut vec = Vec::with_capacity(100);`
> 注意： vec 定义时，需要使用 `mut` 关键字来进行定义，因为 vec 是一个动态大小的序列，所以在定义时需要指定一个初始的容量
```rust
fn demo_1() {
    // 定义 vec
    let mut vec = vec![1, 2, 3, 4, 5];

    // 获取得到 vec 的长度
    let len = vec.len();
    println!("vec 的长度为：{}", len);

    // 访问 vec 的元素
    let first = vec[0];
    let second = vec[1];

    // 定义 vec 另一种简介方式
    let mut vec_1 = vec![4; 5];  // [4, 4, 4, 4, 4]

    // 定义 vec 第三种方式
    let mut vec_2 = Vec::new();
    vec_2.push(1);
    vec_2.push(2);
    vec_2.push(3);
    vec_2.push(4);
    vec_2.push(5);

    // 定义 vec 第四种方式
    let mut vec_3 = Vec::with_capacity(100);
}
```

### 向量的操作
* `vec.push(element)` 实现的是在向量的末尾添加一个元素
* `vec.pop()` 实现的是在向量的末尾移除一个元素
* `vec.insert(element, index)` 实现的是在向量的指定位置插入一个元素
* `vec.remove(index)` 实现的是在向量的指定位置移除一个元素

## 调试
```rust
// 定义一个数组和向量
let arr = [1, 2, 3, 4, 5];
let mut vec = vec![1, 2, 3, 4, 5];

// 普通的调试打印
println!("arr: {}, {}, {}, {}", arr[0], arr[1], arr[2], arr[3]);
// 向量的调试打印
println!("vec: {} {} {} {} {}", vec[0], vec[1], vec[2], vec[3], vec[4]);

// 高效的打印输出
println!("arr: {:?}", arr);  // 直接这样就可以实现对应的迭代打印输出了吧
println!("vec: {:?}", vec);
```