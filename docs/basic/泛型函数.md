# Rust 泛型函数

## 泛型函数
* 核心是为了让我们的的代码变得更具备通用性
* 泛型函数可以接受不同类型的参数，并且返回不同类型的值
* 泛型函数的定义使用 `<T>` 来表示泛型类型参数，其中 `T` 可以是任意的类型占位符
* 泛型函数的调用可以使用 `<T>` 来指定具体的类型，也可以使用类型推导来自动推断类型

* 在现在的大多数的编程语言中都是支持书写泛型函数了的，但是C不行
* C++ 中的泛型的定义就是通过的是我们的 模板 来实现的 `template <typename T>`
* 泛型函数的定义使用 `<T>` 来表示泛型类型参数，其中 `T` 可以是任意的类型占位符
* 泛型函数的调用可以使用 `<T>` 来指定具体的类型，也可以使用类型推导来自动推断类型
```rust
fn f<T>(num1: T, num2: T) -> T {
    num1 + num2
}
fn main() {
    let a = f::<i32>(1, 2);
    println!("a = {}", a);
    let b = f::<f32>(1.0, 2.0);
    println!("b = {}", b);
}
```
```c++
#include <iostream>
#include <stdexcept>

// 开始定义我们的泛型函数
template <typename T>
T f(T num1, T num2) {
    return num1 + num2;
}

template <typename K>
void swap_num(K& num1, K& num2) {
    K temp = num1;
    num1 = num2;
    num2 = temp;
}

template <typename T, int size = 10>
class GenericStack {
private:
    // 定义一些属性
    T elements[size];
    int top;  // 栈顶元素

public: 
    GenericStack() : top(-1) {}

    void push(const T& element) {
        if (isFull()) {
            throw std::overflow_error("栈已满，无法入栈");
        }
        elements[++top] = element;
    }

    T pop() {
        if (isEmpty()) {
            throw std::underflow_error("栈为空，无法出栈");
        }
        return elements[top--];
    }

    T peek() const {
        if (isEmpty()) {
            throw std::underflow_error("栈为空，无栈顶元素");
        }
        return elements[top];
    }

    bool isFull() const {
        return top == size - 1;
    }

    bool isEmpty() const {
        return top == -1;
    }

    int get_size() const {
        return top + 1;
    }
};

int main() {
    GenericStack<int> stack;
    stack.push(1);
    stack.push(2);
    stack.push(3);
    std::cout << "栈的大小为: " << stack.get_size() << std::endl;
    std::cout << "栈顶元素为: " << stack.peek() << std::endl;
    std::cout << "出栈元素为: " << stack.pop() << std::endl;
    std::cout << "栈的大小为: " << stack.get_size() << std::endl;
    std::cout << "栈顶元素为: " << stack.peek() << std::endl;
}
```

## 分析泛型
* 1. 首先会实现寻找得到源代码中的泛型函数的实现，首次进行检查是否具备类型的使用错误
* 2. 再次获取得到源码，根据泛型函数的使用场景，生成对应的调度代码
* 3. 最后进行泛型和使用的时候的代码进行关联的代码生成实现

## 对比
* 使用泛型的时候在代码进行编译的时候相对会慢很多，因为需要明确的根据源码的调度进行构建出对应的每一种重载类型的函数
* 但是编译生成的代码会根据每一种泛型函数的使用场景，生成对应的调度代码，以及进行一定的代码优化实现，所以说最终的代码执行相对更快一些
* 但是由于泛型在编译的时候生成的代码，所以说可能会导致一种现象 `代码膨胀`, 因为每一种泛型函数的使用场景，都会生成对应的代码，所以说如果泛型函数的使用场景很多，那么就会导致生成的代码很多，从而导致代码膨胀的问题

> 所以说泛型是可以解决很多通用性的问题，但是不适合使用一个泛型分发过多的不同类型，否则就会导致`代码过多膨胀`

## 泛型枚举的实现
* 核心就是实现的是定义一些泛型的枚举类型出来，实现我们的程序的合理的执行实现吧
```rust
enum RESULT<T, E> {
    Ok(T),
    Err(E),
}
fn divide(numerator: i32, denominator: i32) -> RESULT<i32, &'static str> {
    if denominator == 0 {
        RESULT::Err("divide by zero")
    } else {
        RESULT::Ok(numerator / denominator)
    }
}
fn show_divide(numerator: i32, denominator: i32) {
    match divide(numerator, denominator) {
        RESULT::Ok(v) => println!("{}", v),
        RESULT::Err(v) => println!("{}", v),
        _ => println!("unknown error"),
    }
}
```