# Rust 内存分配

## Rust 核心的关注点
* 在rust的开发中，常见的时候就是进行分析内存的分析分配问题的探究
* 核心的点在于分析以及的一些特性吧
    * 在处理器寄存器中分配
    * 静态分配
    * 栈分配
    * 堆分配
# C++ 与 Rust 内存分配对比表

| 对比维度         | C++ 实现                                                                 | Rust 实现                                                                 | 核心差异说明                                                                 |
|------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|------------------------------------------------------------------------------|
| 1. 栈分配（自动回收） | **原理**：局部变量存储于栈，函数退出时自动销毁<br>**代码案例**：<br>```cpp#include <iostream>int main() {    int stack_num = 42; // 栈分配    std::string stack_str = "stack string"; // 栈上的字符串对象（内部可能含堆指针）    std::cout << stack_num << " " << stack_str << std::endl;    return 0; // 函数退出，栈变量自动回收}``` | **原理**：`let` 声明的非 `Box`/`Vec` 等类型默认栈分配，作用域结束自动 drop<br>**代码案例**：<br>```rustfn main() {    let stack_num: i32 = 42; // 栈分配    let stack_str: &str = "stack string"; // 字符串字面量（栈上引用，数据存只读段）    let stack_vec: Vec<i32> = vec![1, 2, 3]; // Vec 本身栈分配，内部数据堆分配    println!("{} {} {:?}", stack_num, stack_str, stack_vec);} // 作用域结束，所有栈变量自动 drop``` | C++ 栈对象析构函数自动调用（但需注意避免野指针）；Rust 靠 **所有权机制** 保证无垂悬引用，编译期检查生命周期 |
| 2. 堆分配（手动/半自动回收） | **原理**：`new` 关键字分配，`delete` 手动释放；`new[]` 对应 `delete[]`<br>**代码案例**：<br>```cpp#include <iostream>int main() {    // 单个对象堆分配    int* heap_num = new int(42);    // 数组堆分配    int* heap_arr = new int[3]{1, 2, 3};    std::cout << *heap_num << " " << heap_arr[1] << std::endl;    delete heap_num; // 手动释放单个对象    delete[] heap_arr; // 手动释放数组（不可混用 delete）    return 0;}``` | **原理**：`Box<T>` 实现简单堆分配，所有权转移后自动 `drop`；无需手动释放<br>**代码案例**：<br>```rustfn main() {    // Box<T> 堆分配单个值    let heap_num: Box<i32> = Box::new(42);    // Vec<T> 堆分配动态数组（自动管理长度）    let mut heap_vec: Vec<i32> = Vec::new();    heap_vec.push(1);    heap_vec.push(2);    println!("{} {:?}", heap_num, heap_vec);    // 无需手动释放：Box/Vec 离开作用域自动 drop}``` | C++ 堆内存需手动匹配 `new/delete`（易内存泄漏/double free）；Rust 靠 **Box/Vec 的 Drop  trait** 自动回收，编译期避免内存安全问题 |
| 3. 智能指针（堆分配自动化） | **原理**：`std::unique_ptr`/`std::shared_ptr` 管理堆内存，自动释放<br>**代码案例**：<br>```cpp#include <iostream>#include <memory> // 智能指针头文件int main() {    // unique_ptr：独占所有权    std::unique_ptr<int> up = std::make_unique<int>(42);    // shared_ptr：共享所有权（引用计数）    std::shared_ptr<int> sp1 = std::make_shared<int>(100);    std::shared_ptr<int> sp2 = sp1; // 引用计数+1    std::cout << *up << " " << *sp1 << " " << *sp2 << std::endl;    return 0; // 智能指针析构时自动释放堆内存（引用计数归0时）}``` | **原理**：`Rc<T>`（单线程引用计数）/`Arc<T>`（多线程安全引用计数）<br>**代码案例**：<br>```rustuse std::rc::Rc;use std::sync::Arc;fn main() {    // Rc<T>：单线程共享所有权（引用计数）    let rc1: Rc<i32> = Rc::new(42);    let rc2: Rc<i32> = Rc::clone(&rc1); // 引用计数+1    // Arc<T>：多线程安全共享（原子操作计数）    let arc1: Arc<i32> = Arc::new(100);    let arc2: Arc<i32> = Arc::clone(&arc1);    println!("{} {} {} {}", rc1, rc2, arc1, arc2);} // 离开作用域，引用计数归0时自动释放``` | C++ 智能指针需手动选择 `unique_ptr`/`shared_ptr`（无编译期生命周期检查）；Rust `Rc`/`Arc` 受所有权约束，编译期保证无循环引用（需配合 `Weak<T>` 解决循环） |
| 4. 内存泄漏风险场景 | **代码案例**（未释放堆内存）：<br>```cpp#include <iostream>void leak() {    int* heap_data = new int(42); // 未调用 delete，函数退出后内存泄漏}int main() {    leak();    return 0; // 堆内存未释放，造成泄漏}``` | **代码案例**（编译期禁止泄漏）：<br>```rust// 错误示例：Box 未被使用但会自动 drop，无泄漏fn leak() {    let heap_data: Box<i32> = Box::new(42); // 离开作用域自动 drop}fn main() {    leak();    return 0; // 无内存泄漏}// 主动泄漏（需显式调用 Box::leak）fn active_leak() {    let heap_data: Box<i32> = Box::new(42);    let _leaked: &'static i32 = Box::leak(heap_data); // 显式泄漏（生命周期设为 'static）}``` | C++ 易因忘记 `delete`/异常跳转导致泄漏；Rust 除显式 `Box::leak` 外，编译期通过所有权机制强制自动回收，几乎无隐式泄漏 |

## C++ 和 Rust 内存分配对比
# Rust 与 C++ 内存分配核心数据类型对比表

| 数据类型分类       | C++ 实现（内存分配+核心特性）                                                                 | Rust 实现（内存分配+核心特性）                                                                 | 核心差异总结                                                                 |
|--------------------|----------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| **1. 固定大小数组** | - 类型：`T[N]`（如 `int arr[5]`）<br>- 分配：仅栈分配，大小编译期固定<br>- 特性：无越界检查，随作用域自动销毁 | - 类型：`[T; N]`（如 `[i32; 5]`）<br>- 分配：默认栈分配，可通过 `Box<[T; N]>` 转为堆分配<br>- 特性：编译期越界检查，所有权控制 | C++ 仅栈分配且无安全检查；Rust 支持栈/堆双分配，编译期保障访问安全               |
| **2. 动态数组**     | - 类型：`std::vector<T>`<br>- 分配：堆存储数据，支持动态扩容（需手动管理拷贝/释放时机）<br>- 特性：提供 `push_back`/`pop_back`，对象销毁时释放堆内存 | - 类型：`Vec<T>`<br>- 分配：堆存储数据，默认2倍扩容策略<br>- 特性：所有权机制自动释放堆内存，支持 `into_boxed_slice` 转不可变切片 | 扩容逻辑类似；Rust 无需手动管理内存，C++ 需注意避免拷贝开销与内存泄漏           |
| **3. 键值对集合**   | - 类型：`std::map`（红黑树）/`std::unordered_map`（哈希表）<br>- 分配：堆存储节点，复杂类型需手动实现哈希函数<br>- 特性：迭代器可能引发悬垂指针 | - 类型：`std::collections::HashMap`（哈希表）/`BTreeMap`（B树）<br>- 分配：堆存储键值对，基础类型默认实现 `Hash` trait<br>- 特性：禁止二次借用，编译期阻断悬垂引用 | C++ 需手动实现哈希逻辑；Rust 靠所有权机制避免指针安全问题，API 更简洁           |
| **4. 字符串**       | - 类型：`std::string`（动态堆字符串）/`const char*`（只读区字面量）<br>- 分配：`std::string` 堆存数据，支持隐式转 `const char*`<br>- 特性：赋值默认拷贝堆数据 | - 类型：`String`（动态堆字符串）/`&str`（字符串切片）<br>- 分配：`String` 堆存数据，`&str` 仅存指针+长度（无新分配）<br>- 特性：严格所有权转移，需显式 `as_str()` 转换 | C++ 隐式转换易引发安全问题；Rust 区分「所有权字符串」与「切片引用」，避免隐式错误 |
| **5. 智能指针**     | - 类型：`std::unique_ptr<T>`（独占）/`std::shared_ptr<T>`（共享，引用计数）<br>- 分配：`std::make_unique`/`std::make_shared` 显式堆分配<br>- 特性：无编译期生命周期检查，可能出现循环引用 | - 类型：`Box<T>`（独占堆指针）/`Rc<T>`（单线程共享）/`Arc<T>`（多线程共享）<br>- 分配：`Box::new`/`Rc::new` 显式堆分配<br>- 特性：编译期生命周期检查，`Weak<T>` 解决循环引用 | C++ 智能指针无安全检查；Rust 靠所有权+生命周期，从编译期阻断循环引用与悬垂指针   |

## 线性寻址
* 在任何的计算机内部的话都是具备一个可读可写的存储器，这个就是我们的 `RAM`，核心是由一个长的字节组成的吧，按照位置进行访问实现的呐
* 目前的计算机分类
    * 1. 一次只可以运行一个进程的机器，并且这个进程直接使用物理内存地址，这个就是 `实内存系统`
    * 2. 可以运行多个进程的操作系统，该系统会为我们的每个进程分配一个 `虚拟内存空间`，每个进程只能访问自己的虚拟内存空间，而不能访问其他进程的虚拟内存空间，这个就是 `虚拟内存系统`
    * 3. 虚拟内存系统的核心就是 `分页`，每个进程的虚拟内存空间会被分成很多的页面，每个页面的大小是固定的，每个页面会被映射到物理内存中的一个页面，这个就是 `分页映射`
---
> 串行（serial）：最基础的任务执行的顺序，也就是`一个任务执行完后，再进行执行下一个任务`，整体来说，执行的过程就是一个一个的`执行流`，在串行的任务流中，我们的每个任务是不存在重叠，同时执行的情形出现的呐，也就是说明：`前一个任务的执行完毕是下一个任务执行的前提`，由于无需处理任务切换和资源竞争，逻辑简单，但会完全占用硬件资源，导致资源利用率低 —— 比如单 CPU 核心在执行一个任务时，其他任务只能排队等待。

> 简单的例子就是：在分析某个任务的执行的时候，我们的思考过程就是：先执行完任务一，然后执行任务二，最后得到最终的结果，将结果进行返回即可
---
> 并发（concurrency）:并发指多个任务在 “同一时间段内交替执行”—— 宏观上看，这些任务像是 “同时进行”；但微观上，由于硬件资源有限（如单 CPU 核心），任务会被操作系统按一定策略（如时间片轮转）切换执行：给每个任务分配短暂的时间片（比如 10ms），时间到后保存当前任务状态，切换到下一个任务，循环往复。这种模式的核心是 “任务调度”，通过快速切换让多个任务 “看起来同时运行”，但会产生切换开销（保存 / 恢复任务上下文），且需处理任务间的资源竞争问题（如多个任务读写同一数据）。​
---
> 并行（parallelism）：并行指多个任务在 “同时执行”，利用多核 CPU 或多个 CPU 核心同时处理不同任务，以提升整体处理能力。与并发不同，并行任务在不同时间点同时运行，不存在任务切换。并行通常需要编程语言或框架支持，如 Rust 的 `std::thread` 或 `std::async`。
---
> 同步（synchronization）：同步是多任务场景下的 “秩序保障机制”，核心是协调多个任务的执行顺序，确保任务按预期的依赖关系执行，避免 “先使用后初始化”“数据读写冲突” 等错误。同步的本质是 “控制任务执行时机”：当任务未满足执行条件（如资源被占用、依赖任务未完成）时，会主动暂停（阻塞），直到条件满足才继续执行。实现同步需依赖 “同步原语”，如互斥锁（Mutex，防止多个任务同时修改同一资源）、信号量（Semaphore，控制同时访问资源的任务数量）、条件变量（Condition Variable，等待特定条件触发），但不当使用可能导致 “死锁”（多个任务互相等待对方释放资源，永久阻塞）。
---
> 异步（asynchronous）：异步是多任务场景下的 “非阻塞执行模式”—— 当发起一个任务（如网络请求、文件 IO）后，当前流程不等待任务完成，而是继续执行其他操作；待目标任务完成后，通过 “回调函数”“事件通知”“Future/Promise” 等方式，将结果反馈给当前流程。异步的核心是 “事件驱动”：任务的执行依赖外部事件（如网络响应到达、文件读取完成），而非主动等待；它通常依赖 “异步运行时”（如 Node.js 的事件循环、Rust 的 Tokio）管理任务调度，避免线程阻塞，能以极少的线程处理大量任务（如单线程处理上万级网络请求），大幅降低线程切换开销。
---
> 多线程（multiThreading）: 多线程是进程内的 “轻量级并发 / 并行方案”—— 在一个进程（操作系统资源分配的基本单位）内，创建多个独立的 “线程”（CPU 调度的基本单位），所有线程共享进程的内存空间（如全局变量、堆内存、文件句柄），但拥有各自的栈空间和寄存器状态。线程的创建和切换成本远低于进程（无需复制整个进程的内存空间），因此适合实现细粒度的并发 / 并行。多线程可在单核心上通过任务切换实现并发，也可在多核心上实现并行；但由于共享内存，需通过同步机制（如锁、原子变量）避免 “数据竞争”（多个线程同时读写同一非原子数据，导致结果异常）。
```C++
#include <thread>
#include <vector>
#include <iostream>

void sum_part(const std::vector<int>& arr, int start, int end, int& result) {
    result = 0;
    for (int i = start; i < end; i++) {
        result += arr[i];
    }
}

int main() {
    std::vector<int> arr = {1,2,3,4,5,6,7,8};
    int res1, res2;
    // 创建2个线程，分别计算[0,4)和[4,8)区间的和
    std::thread t1(sum_part, std::ref(arr), 0, 4, std::ref(res1));
    std::thread t2(sum_part, std::ref(arr), 4, 8, std::ref(res2));
    
    t1.join(); // 等待线程1完成
    t2.join(); // 等待线程2完成
    
    int total = res1 + res2;
    std::cout << "总和：" << total << std::endl; // 输出36
    return 0;
}
```
---
> 多进程（multiProcess）:多进程是操作系统层面的 “独立并行 / 并发方案”—— 操作系统创建多个独立的 “进程”，每个进程拥有完整的资源空间（如独立的内存地址空间、文件句柄、进程控制块），进程间内存完全隔离（一个进程无法直接访问另一个进程的内存）。进程的创建和切换成本高（需复制内存空间、初始化资源），但安全性高（一个进程崩溃不会影响其他进程）。多进程主要通过 “进程间通信（IPC）” 交换数据，常见的 IPC 方式有管道（Pipe）、消息队列（Message Queue）、共享内存（Shared Memory，需同步机制）、套接字（Socket）；多进程可在多核心上实现并行，也可在单核心上通过进程切换实现并发。
```python
from multiprocessing import Process, Queue

def calculate_square(num, result_queue):
    square = num * num
    result_queue.put(square)  # 将结果存入队列（IPC）

if __name__ == "__main__":
    q = Queue()
    # 创建2个进程，分别计算3和4的平方
    p1 = Process(target=calculate_square, args=(3, q))
    p2 = Process(target=calculate_square, args=(4, q))
    
    p1.start()
    p2.start()
    
    p1.join()  # 等待进程1完成
    p2.join()  # 等待进程2完成
    
    # 从队列获取结果
    print("3的平方：", q.get())  # 输出9
    print("4的平方：", q.get())  # 输出16
```

| 通信机制       | 核心原理                                                                 | 前端生态适用场景                                                                 | 优缺点总结                                                                 |
|----------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------|
| 1. 套接字（Socket） | 基于 TCP/UDP 协议，通过网络端口实现跨设备/跨进程通信，是“网络级 IPC”。     | 前端（浏览器/Node.js）与后端服务进程通信（如前端 axios 调用后端 API、Node.js 微服务间通信）。 | 优点：跨设备、跨语言、适用广；缺点：网络开销略高，需处理连接管理。         |
| 2. 管道（Pipe）     | 基于文件描述符的“单向数据流通道”，分为匿名管道（父进程与子进程）和命名管道（无亲缘关系进程）。 | Node.js 中父进程与子进程通信（如前端构建工具中，主进程通过管道接收子进程的编译日志）。       | 优点：轻量、无网络开销；缺点：单向通信、仅支持本地进程，前端浏览器环境不可用。 |
| 3. 消息队列（Message Queue） | 基于“队列”数据结构，进程通过“发送消息”和“接收消息”接口交互，支持异步通信。 | Electron 主进程与渲染进程通信（如渲染进程发送“打开文件”请求，主进程处理后返回结果）、Node.js 进程间解耦通信。 | 优点：异步、解耦、支持多进程读写；缺点：需处理消息积压，浏览器环境需依赖 Electron 等框架。 |
| 4. 共享内存（Shared Memory） | 多个进程映射同一块物理内存，直接读写共享区域实现通信，需配合同步机制（如信号量）避免冲突。 | 前端高性能场景（如 Electron 中主进程与渲染进程共享大体积数据，如视频帧、大型 JSON，避免数据拷贝）。 | 优点：速度最快（无数据拷贝）；缺点：需处理同步问题，浏览器原生不支持，依赖框架底层能力。 |
| 5. 进程间事件通知（如 Electron IPC、Browser 消息通道） | 框架封装的“事件驱动型 IPC”，基于“发送事件-监听事件”模式，简化通信逻辑。   | Electron 主进程与渲染进程通信（如前端页面触发“登录”事件，主进程处理后发送“登录结果”事件）、浏览器中跨窗口进程通信（如 postMessage）。 | 优点：API 简洁、适配前端事件模型；缺点：依赖特定框架，跨框架兼容性差。     |

```javascript
// backend/websocket-server.js
const WebSocket = require('ws');
const http = require('http');
const express = require('express');

// 1. 创建 Express 服务（用于提供前端页面）
const app = express();
app.use(express.static('frontend')); // 托管前端静态文件

// 2. 创建 HTTP 服务器，同时挂载 WebSocket 服务
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// 3. 存储在线客户端（多前端页面进程连接）
const clients = new Set();

// 4. 监听 WebSocket 连接
wss.on('connection', (ws) => {
  console.log('前端进程已连接');
  clients.add(ws);

  // 4.1 监听前端发送的消息（如“订阅消息推送”请求）
  ws.on('message', (data) => {
    const message = JSON.parse(data);
    switch (message.type) {
      case 'SUBSCRIBE':
        ws.send(JSON.stringify({
          type: 'SUBSCRIBE_SUCCESS',
          content: `已订阅 ${message.target} 类型消息`
        }));
        break;
      case 'SEND_MESSAGE':
        // 转发消息给所有在线前端进程（群聊功能）
        clients.forEach((client) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'GROUP_MESSAGE',
              sender: message.sender,
              content: message.content,
              time: new Date().toLocaleString()
            }));
          }
        });
        break;
      default:
        ws.send(JSON.stringify({ type: 'ERROR', content: '未知消息类型' }));
    }
  });

  // 4.2 监听连接关闭
  ws.on('close', () => {
    console.log('前端进程已断开连接');
    clients.delete(ws);
  });

  // 4.3 模拟第三方服务推送消息（如后端定时拉取数据后推送给前端）
  const mockPushInterval = setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'PUSH_MESSAGE',
        content: `实时数据更新：${Math.random().toFixed(2)}`,
        time: new Date().toLocaleString()
      }));
    }
  }, 5000);

  // 4.4 连接关闭时清除定时器
  ws.on('close', () => {
    clearInterval(mockPushInterval);
    clients.delete(ws);
  });
});

// 5. 启动服务器（端口 3000）
server.listen(3000, () => {
  console.log('后端进程启动：http://localhost:3000');
  console.log('WebSocket 服务就绪，等待前端进程连接');
});
```
```html
<!-- frontend/index.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>前端-后端 Socket 通信示例</title>
  <style>
    .message-list { height: 300px; overflow-y: auto; border: 1px solid #eee; padding: 10px; margin: 10px 0; }
    .message { margin: 5px 0; padding: 8px; border-radius: 4px; }
    .push-message { background: #e3f2fd; }
    .group-message { background: #f1f8e9; }
    .error-message { background: #ffebee; }
  </style>
</head>
<body>
  <h1>实时消息通信</h1>
  <div class="message-list" id="messageList"></div>
  
  <div>
    <input type="text" id="senderInput" placeholder="输入你的名字" value="前端用户">
    <input type="text" id="contentInput" placeholder="输入消息内容">
    <button onclick="sendGroupMessage()">发送群聊消息</button>
    <button onclick="subscribeMessage()">订阅实时推送</button>
  </div>

  <script>
    // 1. 建立 WebSocket 连接（连接后端进程）
    const ws = new WebSocket('ws://localhost:3000');
    const messageList = document.getElementById('messageList');
    const senderInput = document.getElementById('senderInput');
    const contentInput = document.getElementById('contentInput');

    // 2. 监听连接成功
    ws.onopen = () => {
      addMessage('连接成功', '系统消息', 'system-message');
    };

    // 3. 监听后端发送的消息
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      switch (message.type) {
        case 'SUBSCRIBE_SUCCESS':
          addMessage(message.content, '订阅通知', 'subscribe-message');
          break;
        case 'PUSH_MESSAGE':
          addMessage(message.content, `实时推送（${message.time}）`, 'push-message');
          break;
        case 'GROUP_MESSAGE':
          addMessage(message.content, `群聊消息 [${message.sender}]（${message.time}）`, 'group-message');
          break;
        case 'ERROR':
          addMessage(message.content, '错误通知', 'error-message');
          break;
      }
    };

    // 4. 监听连接关闭
    ws.onclose = () => {
      addMessage('连接已断开，正在重连...', '系统消息', 'error-message');
      // 自动重连逻辑
      setTimeout(() => window.location.reload(), 3000);
    };

    // 5. 工具函数：添加消息到页面
    function addMessage(content, title, className) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${className}`;
      messageDiv.innerHTML = `<strong>${title}</strong>：${content}`;
      messageList.appendChild(messageDiv);
      // 滚动到最新消息
      messageList.scrollTop = messageList.scrollHeight;
    }

    // 6. 发送群聊消息（前端 → 后端 → 所有前端）
    function sendGroupMessage() {
      const sender = senderInput.value.trim();
      const content = contentInput.value.trim();
      if (!sender || !content) return alert('请输入名字和消息内容');
      
      ws.send(JSON.stringify({
        type: 'SEND_MESSAGE',
        sender,
        content
      }));
      contentInput.value = ''; // 清空输入框
    }

    // 7. 订阅实时推送（前端 → 后端）
    function subscribeMessage() {
      ws.send(JSON.stringify({
        type: 'SUBSCRIBE',
        target: 'realtime_data'
      }));
    }
  </script>
</body>
</html>
```
```javascript
// main/main.js
const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const fs = require('fs');
const path = require('path');

// 1. 创建渲染进程窗口
let mainWindow;
function createWindow() {
  mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'), // 预加载脚本（安全通信）
      contextIsolation: true, // 开启上下文隔离（安全策略）
      nodeIntegration: false // 禁用 Node.js 集成（安全策略）
    }
  });

  // 加载前端渲染进程页面
  mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));
}

// 2. 监听渲染进程的“读取文件”请求
ipcMain.handle('read-local-file', async (event, filePath) => {
  try {
    // 2.1 验证文件路径（安全校验，避免路径遍历攻击）
    const safePath = path.resolve(app.getPath('documents'), filePath);
    if (!safePath.startsWith(app.getPath('documents'))) {
      throw new Error('无权访问该目录，仅允许读取文档目录下的文件');
    }

    // 2.2 获取文件大小（用于进度计算）
    const fileStats = fs.statSync(safePath);
    const fileSize = fileStats.size;
    let readSize = 0;

    // 2.3 流式读取文件（处理大文件，避免内存溢出）
    const readStream = fs.createReadStream(safePath, { highWaterMark: 64 * 1024 }); // 64KB 缓冲区
    const chunks = [];

    // 2.4 监听读取进度，发送进度通知给渲染进程
    readStream.on('data', (chunk) => {
      chunks.push(chunk);
      readSize += chunk.length;
      const progress = Math.round((readSize / fileSize) * 100);
      // 发送进度事件（主进程 → 渲染进程）
      mainWindow.webContents.send('read-file-progress', { progress, filePath });
    });

    // 2.5 等待读取完成，返回文件内容
    return new Promise((resolve, reject) => {
      readStream.on('end', () => {
        const fileContent = Buffer.concat(chunks).toString('utf8');
        resolve({
          success: true,
          content: fileContent,
          fileInfo: { name: path.basename(safePath), size: fileSize }
        });
      });

      readStream.on('error', (err) => {
        reject(new Error(`文件读取失败：${err.message}`));
      });
    });
  } catch (err) {
    return {
      success: false,
      error: err.message
    };
  }
});

// 3. 监听渲染进程的“选择文件”请求（打开系统文件选择器）
ipcMain.handle('open-file-dialog', async () => {
  const result = await dialog.showOpenDialog(mainWindow, {
    title: '选择要读取的文件',
    defaultPath: app.getPath('documents'),
    filters: [
      { name: '文本文件', extensions: ['txt', 'md', 'json'] },
      { name: '所有文件', extensions: ['*'] }
    ],
    properties: ['openFile'] // 仅允许选择文件
  });

  // 返回选择的文件路径（相对文档目录的路径，避免暴露绝对路径）
  if (!result.canceled && result.filePaths.length > 0) {
    const absolutePath = result.filePaths[0];
    const relativePath = path.relative(app.getPath('documents'), absolutePath);
    return { success: true, relativePath };
  }
  return { success: false, error: '用户取消选择' };
});

// 4. Electron 应用就绪后创建窗口
app.whenReady().then(createWindow);

// 5. 处理窗口关闭事件
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) createWindow();
});


// =========
// main/preload.js
const { contextBridge, ipcRenderer } = require('electron');

// 暴露安全的 IPC 接口给渲染进程（避免直接暴露 ipcRenderer）
contextBridge.exposeInMainWorld('electronIPC', {
  // 渲染进程 → 主进程：打开文件选择器
  openFileDialog: () => ipcRenderer.invoke('open-file-dialog'),
  // 渲染进程 → 主进程：读取本地文件
  readLocalFile: (filePath) => ipcRenderer.invoke('read-local-file', filePath),
  // 主进程 → 渲染进程：监听文件读取进度
  onReadFileProgress: (callback) => {
    ipcRenderer.on('read-file-progress', (event, progressData) => callback(progressData));
    // 返回取消监听的函数（避免内存泄漏）
    return () => ipcRenderer.removeAllListeners('read-file-progress');
  }
});
```